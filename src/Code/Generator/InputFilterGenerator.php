<?php
/**
 * Sake
 *
 * @link      http://github.com/sandrokeil/CodeGenerator for the canonical source repository
 * @copyright Copyright (c) 2014 Sandro Keil
 * @license   http://github.com/sandrokeil/CodeGenerator/blob/master/LICENSE.txt New BSD License
 */

namespace Sake\CodeGenerator\Code\Generator;

use Sake\CodeGenerator\Code\Metadata\MetadataInfo;
use Zend\Code\Generator\DocBlockGenerator;
use Zend\Code\Generator\FileGenerator;
use Zend\Code\Generator\ClassGenerator;
use Zend\Code\Generator\MethodGenerator;

/**
 * Input filter generator
 *
 * Generates zend framework 2 ipnut filter depending on given meta data (table or entity definitions).
 */
class InputFilterGenerator extends AbstractGenerator
{
    /**
     * FCQN of class to extends
     *
     * @var string
     */
    protected $classToExtend = '\Zend\InputFilter\InputFilter';

    /**
     * Namespace
     *
     * @var string
     */
    protected $namespace = 'InputFilter';

    /**
     * Provide min and max values for different data types
     *
     * @var array
     */
    protected $minMaxValues = array(
        'tinyint' => array(
            '0' => array('min' => 0, 'max' => 255),
            '1' => array('min' => -128, 'max' => 127)
        ),
        'smallint' => array(
            '0' => array('min' => 0, 'max' => 65535),
            '1' => array('min' => -32768, 'max' => 32767)
        ),
        'mediumint' => array(
            '0' => array('min' => 0, 'max' => 16777215),
            '1' => array('min' => -8388608, 'max' => 8388607)
        ),
        'integer' => array(
            '0' => array('min' => 0, 'max' => 4294967295),
            '1' => array('min' => -2147483648, 'max' => 2147483647)
        ),
        'bigint' => array(
            '0' => array('min' => 0, 'max' => 18446744073709551615),
            '1' => array('min' => -9223372036854775808, 'max' => 9223372036854775807)
        ),
    );

    /**
     * Returns file name for specifc generated type
     *
     * @param MetadataInfo $metadata
     * @return string
     */
    public function getName(MetadataInfo $metadata)
    {
        return 'InputFilter/' . $this->convertName($metadata->getTable('name'));
    }

    /**
     * Generate input filter init method which calls add functions.
     *
     * @param MetadataInfo $metadataInfo
     * @return MethodGenerator
     */
    protected function getInitMethod(MetadataInfo $metadataInfo)
    {
        $body = '';

        foreach ($metadataInfo->getColumns() as $name => $data) {
            // dont add primary keys
            if (!empty($data['id'])) {
                continue;
            }
            $body .= '$this->addElement' . $this->convertName($data['columnName']) . '();' . PHP_EOL;
        }

        return new MethodGenerator(
            'init',
            array(),
            MethodGenerator::FLAG_PUBLIC,
            $body,
            new DocBlockGenerator('Initialize input filter elements')
        );
    }

    /**
     * Generates input filter class
     *
     * @param MetadataInfo $metadata
     * @return FileGenerator
     */
    public function generateClass(MetadataInfo $metadata)
    {
        $methods = array($this->getInitMethod($metadata));

        foreach ($metadata->getColumns() as $name => $data) {
            // dont add primary keys
            if (!empty($data['id'])) {
                continue;
            }
            $methods[] = $this->getAddMethod($data);
        }

        // we dont need validators for foreign keys because select element adds in array validator automatically
        $file = new FileGenerator(array(
            'classes' => array(
                new ClassGenerator(
                    $metadata->getName(),
                    'Form',
                    null,
                    $this->classToExtend,
                    array(
                        'InitializableInterface'
                    ),
                    array(),
                    $methods,
                    new DocBlockGenerator(
                        'Input filter for ' . $metadata->getName(),
                        'This input filter can be used to validate data for ' . $metadata->getName()
                    )
                ),
            ),
            'namespace' => $this->namespace,
            'uses' => array(
                '\Zend\Stdlib\InitializableInterface'
            ),
            'docBlock' => new DocBlockGenerator(
                'Generated by Sake\CodeGenerator http://github.com/sandrokeil/CodeGenerator'
            )
        ));
        return $file;
    }

    /**
     * Returns the form element type depending on table information.
     *
     * @param array $metadata Field metadata
     * @return string Element type
     */
    protected function getElementType(array $metadata)
    {
        switch ($metadata['type']) {
            case 'text':
                $type = 'textarea';
                break;

            default:
                $type = 'text';
                break;
        }
        return $type;
    }

    /**
     * Returns string length validator definition
     *
     * @param $metadata
     * @return string
     */
    protected function getStringLengthValidator($metadata)
    {
        if (empty($metadata['length'])) {
            return '';
        }

        $validator = "array(
                'name' => 'StringLength',
                'options' => array(
                    'encoding' => 'UTF-8',
                    'min' => 1,
                    'max' => " . (int) $metadata['length'] . ",
                ),
            ),";
        return PHP_EOL . $this->getIntendation(3) . $validator . PHP_EOL . $this->getIntendation(2);
    }

    /**
     * Builds the option e.g. for filters or validators.
     *
     * @param array $types
     * @return string Code
     */
    protected function getFilter(array $types)
    {
        $definition = '';

        // $option is more than once used for indendation
        foreach ($types as $type) {
            $definition .= PHP_EOL . $this->getIntendation(3) . "array('name' => '" . $type . "'),";
        }
        return $definition . PHP_EOL . $this->getIntendation(2);
    }

    /**
     * Returns a numeric validator with minimum and maximum definition.
     *
     * @param array $ranges min and max definition
     * @return string Code
     */
    protected function getNumericValidator(array $ranges)
    {
        return PHP_EOL . $this->getIntendation(3) . "array(
                'name' => 'Between',
                'options' => array(
                    'min' => " . $ranges['min'] . ",
                    'max' => " . $ranges['max'] . ",
                    'inclusive' => true
                )
            )," . PHP_EOL . $this->getIntendation(2);
    }

    /**
     * Adds a date validator.
     *
     * @param string $type Field type
     * @return string Code
     */
    protected function getDateValidator($type)
    {
        $format = 'Y-m-d';

        if ($type == 'datetime'
            || $type == 'timestamp'
        ) {
            $format .= ' H:i:s';
        }
        return PHP_EOL . $this->getIntendation(3) . "array(
                'name' => 'Date',
                'options' => array('format' => '" . $format . "')
            )," . PHP_EOL . $this->getIntendation(2);
    }

    /**
     * Returns minimum and maximum value of floats depending on precision and scale
     *
     * @param array $metadata Column metadata
     * @return array min, max are indexes
     */
    protected function getFloatMinAndMax(array $metadata)
    {
        $unsigned = !empty($metadata['unsigned']);
        // use float default if not exists
        if (empty($metadata['precision'])) {
            $metadata['precision'] = 10;
            $metadata['scale'] = 2;
        }
        $max = $metadata['precision'] - $metadata['scale'];
        $max = (float) str_pad('', $max, '9');
        $min = (float) ($unsigned ? 0 : ('-' . $max));
        return array('min' => $min, 'max' => $max);
    }

    /**
     * Returns add method with filter definitions.
     *
     * @param array $data
     * @return MethodGenerator
     */
    protected function getAddMethod(array $data)
    {
        $name = $this->convertName($data['columnName']);
        $default = 'array(%s)';
        $filter = '';
        $validator = '';


        switch ($data['type']) {
            case 'bigint': // Break intentionally omitted
            case 'mediumint': // Break intentionally omitted
            case 'smallint': // Break intentionally omitted
            case 'tinyint': // Break intentionally omitted
            case 'integer':
                $filter    = $this->getFilter(array('Int'));
                $validator = $this->getNumericValidator(
                    $this->minMaxValues[$data['type']][empty($data['unsigned']) ? 0 : 1]
                );
                break;

            case 'decimal': // Break intentionally omitted
            case 'float': // Break intentionally omitted
            case 'double':
                $filter    = $this->getFilter(array('Float'));
                $validator = $this->getNumericValidator($this->getFloatMinAndMax($data));
                break;

            case 'char': // Break intentionally omitted
            case 'varchar':  // Break intentionally omitted
            case 'string':
                $filter = $this->getFilter(array('StringTrim', 'StripTags'));
                $validator = $this->getStringLengthValidator($data);
                break;

            case 'tinytext': // Break intentionally omitted
            case 'mediumtext': // Break intentionally omitted
            case 'longtext': // Break intentionally omitted
            case 'text':
                $filter = $this->getFilter(array('StringTrim', 'StripTags'));
                break;

            case 'date': // Break intentionally omitted
            case 'datetime': // Break intentionally omitted
            case 'timestamp':
                $filter = $this->getFilter(array('StringTrim'));
                $validator = $this->getDateValidator($data['type']);
                break;

            default:
                // no validator or filter
                break;
        }

        $body = <<<'EOT'
    $this->add(
    array(
        'name' => '%s',
        'required' => true,
        'filters' => %s,
        'validators' => %s,
    )
);

EOT;

        return new MethodGenerator(
            'addElement' . $name,
            array(),
            MethodGenerator::FLAG_PROTECTED,
            sprintf($body, lcfirst($name), sprintf($default, $filter), sprintf($default, $validator)),
            new DocBlockGenerator(sprintf('Adds element %s to input filter', lcfirst($name)))
        );
    }
}
